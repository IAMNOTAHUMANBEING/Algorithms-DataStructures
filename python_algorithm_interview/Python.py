# 파이썬
# 디버깅: print, pprint(locals())
# 코딩 스타일: 파이썬의 PEP8, 구글의 파이썬 스타일 가이드 참조
# - 함수의 기본 값으로 가변 객체를 사용하지 않는다: 함수가 객체를 수정하면 기본값이 변경된다. [], {} 사용 지향, None 명시적 할당 좋음
# - True, False를 판별할 때는 암시적인 방법을 사용하라: if foo: (o) if foo != [] (x), if not users: (o) if len(users) == 0 (x)
# 정수 비교를 처리할 때는 암시적 방법보단 명시적으로 값을 비교하는 것이 좋다.
# - 최대 줄 길이는 80자로 한다
# - 세미콜론으로 줄을 끝내선 안되며 세미콜론을 사용해 같은 줄에 두 문장을 써서도 안된다
# - 네이밍은 스네이크 케이스로

# 빅오: 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기, 알고리즘의 시간 복잡도와 공간 복잡도가 어떻게 증가하는지 분류하는 데 사용
# O(1): 해시 테이블의 조회와 삽입
# O(logn): 이진 검색
# O(n): 선형 시간 알고리즘, ex. 정렬되지 않은 리스트의 최대 최소
# O(nlogn): 병합 정렬 같은 효율 좋은 정렬 알고리즘, 비교 기반 정렬 알고리즘은 아무리 좋아도 O(nlogn)보다 빠를 수 없음
# 팀소트는 입력값이 최선인 경우 비교를 건너뛰어 O(n)이 될 수 있음
# O(n^2): 버블 정렬
# O(2^n): 피보나치 재귀 알고리즘
# O(n!): 외판원 문제 브루트 포스 풀이
# 상한과 최악: 빅오는 복잡한 함수를 적당히 표현하는 방법일 뿐 최악, 평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 점에 유의
# 분할 상환 분석: 모든 연산들이 수행되는 동안 각 연산의 평균적인 수행 시간을 분석하는 방법, 연산의 시퀀스를 수행할 때 길게 걸릴 때의 수행 시간을 잘 쪼갠 후(분할) 짧게 걸릴 때에다 재분배
# 병렬화: 일부 알고리즘은 병렬 연산으로 이용해 실행속도를 높일 수 있다. 병렬화 가능성이 알고리즘의 우수성 평가 척도가 되기도 함

# 자료형(지원 타입 형태: 객체)
# None: class None Type
# 숫자: 정수형(정수int, 불리언bool), 실수float
# 임의 정밀도 정수형: 무제한 자릿수를 가짐. 정수를 숫자의 배열로 간주하여 처리
# 집합형: 순서와 중복이 없는 자료형 ex. 집합set
# 매핑: 키와 자료형으로 구성된 복합 자료형 ex. 딕셔너리dict
# 시퀸스: 순서 있게 나열한 자료형 ex. 불변(문자열str, 튜플tuple, 바이트bytes), 가변(리스트list)
# 객체 자료형: 변수가 메모리에 저장된 값을 담는게 아니라 객체의 주소를 담는다.
# 불변 객체: bool, int, float, tuple, str
# 가변 객체: list, set, dict
# C++ 참조와 차이: C++은 참조 변수에 값을 할당하면 참조 대상 또한 할당된 값으로 변경된다. 하지만 파이썬은 참조 변수에 값을 할당하면
# 참조 변수가 새로운 값을 참조하고 기존 값과 그 값을 참조하고 있던 변수들은 그대로 유지된다.
# is 는 id 비교, == 은 값을 비교
# 자료형: 컴파일러 또는 인터프리터에게 프로그래머가 데이터를 어떻게 사용하는지 알려주는 일종의 데이터 속성, 자료구조에 비해 구체적
# 자료구조: 데이터에 효율적으로 접근하고 조작하기 위한 데이터의 조직, 관리, 저장구조.
# 추상 자료형ADT: 해당 유형 자료에 대한 연산을 명기한 것. 행동만 정의할 뿐 실제 구현 방법은 명시하지 않는다.

# 리스트: 순서대로 저장하는 시퀸스이자 변경 가능한 목록, 객체에 대한 포인터 목록
# 딕셔너리: 불변객체를 키로 사용, 해시 테이블을 이용해 자료 저장, 대부분의 연산이 O(1)