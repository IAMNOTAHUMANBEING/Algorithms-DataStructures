# 해시 테이블: 키를 값에 매핑할 수 있는 구조인 연관 배열 추상자료형을  구현하는 자료구조
# 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이라는 점

# 해시함수: 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수 ex. ABC -> A1, 123AVX -> CB
# 해싱: 해시 테이블을 인덱싱 하기 위해 해시함수를 사용하는 것

# 성능 좋은 해시함수란?
# 해시 함수 값 충돌 최소화
# 쉽고 빠른 연산
# 해시 테이블 전체에 해시 값이 균일하게 분포
# 사용할 키의 모든 정보를 이용하여 해싱
# 해시 테이블 사용 효율이 높을 것

# 생일이 같을 확률
import random

TRIALS = 100000
same_birthdays = 0

for _ in range(TRIALS):
    birthdays = []
    # 23명이 모였을 때, 생일이 같을 경우 same_birthdays += 1
    for i in range(23):
        birthday = random.randint(1, 365)
        if birthday in birthdays:
            same_birthdays += 1
            break
        birthdays.append(birthday)

# 전체 10만 번 실험 중 생일이 같은 실험의 확률
print(f'{same_birthdays / TRIALS * 100}%')
# 50% 나옴. 직관적인 판단과 달리 충돌은 생각보다 쉽게 일어난다.

# 비둘기집 원리: n개 아이템을 m개 컨테이너에 넣을 때, n > m 이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어있다는 원리
# 9개의 공간에 10개의 아이템이 들어온다면 좋은 해시함수는 1번의 충돌만 일어나게 하고 안좋은 해시함수는 9번 모두 충돌하게 한다

# 로드팩터: 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다. 비율에 따라 해시함수를 재작성 하거나 해시테이블의 크기를 재조정
# 해시함수가 키들을 잘 분산해주는지 효율성 측정에도 사용함.

# 충돌 처리 방법
# 개별 체이닝: 해시 테이블의 기본 방식. 같은 인덱스가 이미 존재할 경우 연결 리스트로 연결
# 오픈 어드레싱: 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식. 저장 제한이 있고 모든 원소가 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없음
# 가장 간단한 것은 바로 다음 위치를 탐사하는 선형 탐사 방식, 저장 데이터들이 뭉쳐 저장되는 클러스터링 현상이 생겨 효율을 떨어뜨리는 문제가 있음
# 파이썬은 오픈 어드레싱 방식을 사용. 일반적인 경우 체이닝에 비해 어드레싱 방식이 성능이 좋음. 그러나 저장공간이 80%를 넘으면 급격한 성능 저하가 일어남
# 따라서 로드 팩터를 작게 잡아서 성능 저하 문제를 해결함




